"""
Plan Creator - Silver Tier
Document Requirement: "Claude reasoning loop that creates Plan.md files"

Needs_Action folder mein naye files detect hone par automatically
structured Plan.md files banata hai /Plans/ folder mein.
Claude Code in Plan.md files ko padhta hai aur steps execute karta hai.
"""

import time
import logging
from datetime import datetime
from pathlib import Path

from watchers.config import Config


# Action steps templates for each source type
PLAN_STEPS: dict[str, list[str]] = {
    "email": [
        "- [ ] Read full email content",
        "- [ ] Identify sender intent (reply needed / info only / urgent action)",
        "- [ ] Draft reply and save to /Pending_Approval/EMAIL_reply_{timestamp}.md",
        "- [ ] Update Dashboard.md with this email",
        "- [ ] Move original file to /Done when complete",
    ],
    "whatsapp": [
        "- [ ] Read WhatsApp message content",
        "- [ ] Check if invoice, payment, or urgent reply is needed",
        "- [ ] If invoice requested: read /Accounting/Rates.md and generate invoice",
        "- [ ] Create approval file in /Pending_Approval/ before any send action",
        "- [ ] Log interaction and move file to /Done",
    ],
    "file_drop": [
        "- [ ] Inspect dropped file type and contents",
        "- [ ] Categorize: invoice / contract / report / other",
        "- [ ] Extract key data and update relevant vault files",
        "- [ ] Move processed file to /Done",
    ],
    "default": [
        "- [ ] Read the action file thoroughly",
        "- [ ] Determine required response or action",
        "- [ ] Create approval file if external action needed",
        "- [ ] Execute approved action via MCP",
        "- [ ] Update Dashboard.md and move to /Done",
    ],
}


def _parse_frontmatter(filepath: Path) -> dict:
    """Extract YAML frontmatter key-value pairs from a markdown file."""
    metadata: dict = {}
    lines = filepath.read_text().splitlines()
    if not lines or lines[0].strip() != "---":
        return metadata
    try:
        end = lines.index("---", 1)
    except ValueError:
        return metadata
    for line in lines[1:end]:
        if ":" in line:
            key, _, value = line.partition(":")
            metadata[key.strip()] = value.strip()
    return metadata


def _get_steps(source_type: str, metadata: dict) -> list[str]:
    """Return Plan steps for this source type, filling in any template variables."""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    raw_steps = PLAN_STEPS.get(source_type, PLAN_STEPS["default"])
    return [step.replace("{timestamp}", timestamp) for step in raw_steps]


def create_plan_for(action_file: Path, plans_dir: Path, logger: logging.Logger) -> Path:
    """
    Read a Needs_Action file and write a corresponding Plan.md.
    This is the 'reasoning seed' that Claude Code reads to determine its next steps.
    """
    metadata = _parse_frontmatter(action_file)
    source_type = metadata.get("type", "default")
    priority = metadata.get("priority", "medium")
    subject = metadata.get("subject", action_file.stem)

    steps = _get_steps(source_type, metadata)
    steps_text = "\n".join(steps)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    plan_filename = f"PLAN_{action_file.stem}_{timestamp}.md"
    plan_path = plans_dir / plan_filename

    plan_content = f"""---
type: plan
created: {datetime.now().isoformat()}
source_file: {action_file.name}
source_type: {source_type}
priority: {priority}
status: pending
---

# Plan: {subject}

**Created:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Source:** {action_file.name}
**Priority:** {priority}

## Objective
Process `{action_file.name}` and complete all required actions.

## Steps
{steps_text}

## Context
Read source file at: /Needs_Action/{action_file.name}

## Completion Rule
When all steps are checked, output:
`<promise>TASK_COMPLETE</promise>`
and move this file and the source file to /Done.

---
*Auto-generated by Plan Creator*
"""
    plan_path.write_text(plan_content)
    logger.info(f"Created Plan: {plan_filename} for {action_file.name}")
    return plan_path


class PlanCreator:
    """
    Watches /Needs_Action for new .md files and creates Plan.md files in /Plans/.
    Runs as a background thread inside the Orchestrator.
    """

    POLL_INTERVAL = 15  # seconds

    def __init__(self):
        self.vault_path = Config.VAULT_PATH
        self.needs_action = Config.NEEDS_ACTION
        self.plans_dir = Config.PLANS
        self.processed: set[str] = set()
        self.logger = logging.getLogger(self.__class__.__name__)

        self.plans_dir.mkdir(parents=True, exist_ok=True)

    def run(self) -> None:
        """Poll Needs_Action and create Plan.md for each new file."""
        self.logger.info("PlanCreator started â€” watching /Needs_Action for new files")
        while True:
            try:
                for action_file in self.needs_action.glob("*.md"):
                    if action_file.name not in self.processed:
                        create_plan_for(action_file, self.plans_dir, self.logger)
                        self.processed.add(action_file.name)
            except Exception as e:
                self.logger.error(f"PlanCreator error: {e}", exc_info=True)
            time.sleep(self.POLL_INTERVAL)